
import { User, FoodListing, ChatMessage, PointTransaction, B2BListing, CarbonStandard, CarbonProject, ProjectCategory, TradeOffer } from "../types";
import { auth as firebaseAuth, db as firebaseFirestore, app as firebaseApp, USE_FIREBASE } from "./firebaseConfig";
import {
    signInWithEmailAndPassword,
    createUserWithEmailAndPassword,
    signOut,
    updateProfile,
    onAuthStateChanged
} from "firebase/auth";
import {
    collection,
    addDoc,
    query,
    where,
    onSnapshot,
    doc,
    setDoc,
    getDoc,
    updateDoc,
    orderBy,
    deleteDoc,
    getDocs,
    writeBatch,
    runTransaction,
    limit
} from "firebase/firestore";
import { getFunctions, httpsCallable } from "firebase/functions";

// --- REPLATEIQ COMMUNITY PROJECT ---
const COMMUNITY_PROJECT: CarbonProject = {
    id: "PROJ-RIQ-COMMUNITY",
    name: "ReplateIQ Community Aggregation",
    category: ProjectCategory.AvoidedEmissions,
    location: "Global Distributed",
    country: "Global",
    standard: "ReplateIQ Verified",
    methodology: "RIQ-METH-001 (Avoided Food Waste Methane)",
    sdgGoals: [12, 13, 2],
    description: "Credits generated by individual households diverting food waste from landfills through peer-to-peer sharing.",
    image: "https://images.unsplash.com/photo-1542601906990-b4d3fb7d5763?q=80&w=2000&auto=format&fit=crop"
};

// --- INTERFACE ---
interface IDB {
    onAuthStateChanged(callback: (user: User | null) => void): () => void;
    login(email: string, password?: string): Promise<void>;
    signup(user: User): Promise<void>;
    logout(): Promise<void>;
    updateUser(id: string, data: Partial<User>): Promise<void>;
    addPoints(userId: string, amount: number, description: string): Promise<void>;

    // HANDSHAKE PROTOCOL
    broadcastOffer(enterpriseId: string, enterpriseName: string, region: string, price: number): Promise<void>;
    updateOfferPrice(offerId: string, newPrice: number): Promise<void>;
    acceptTradeOffer(offerId: string, userId: string): Promise<void>;
    rejectTradeOffer(offerId: string): Promise<void>;
    subscribeToUserOffers(userId: string, callback: (offers: TradeOffer[]) => void): () => void;
    subscribeToEnterpriseBids(enterpriseId: string, callback: (offers: TradeOffer[]) => void): () => void;

    // B2B Market
    getCommunityProject(): CarbonProject;
    createB2BListing(listing: B2BListing): Promise<void>;
    buyB2BListing(buyerId: string, listingId: string, amountToBuy: number, retire: boolean): Promise<void>;
    subscribeToB2BListings(callback: (listings: B2BListing[]) => void): () => void;

    subscribeToListings(callback: (listings: FoodListing[]) => void): () => void;
    subscribeToMessages(callback: (messages: ChatMessage[]) => void): () => void;
    subscribeToUsers(callback: (users: User[]) => void): () => void;

    addListing(listing: FoodListing): Promise<void>;
    updateListing(id: string, data: Partial<FoodListing>): Promise<void>;
    deleteListing(id: string): Promise<void>;
    sendMessage(msg: ChatMessage): Promise<void>;
    getAllUsers(): Promise<User[]>;
    getCurrentUser(): User | null;

    // Legacy
    transferCredits(userId: string, region: string, amount: number): Promise<void>;
    unclaimListing(id: string): Promise<void>;
    verifyTransaction(listingId: string, code: string): Promise<boolean>;
}

// --- HELPER ---
const sanitizeData = (data: any) => {
    const seen = new WeakSet();
    const clean = (obj: any): any => {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Date) return obj;
        if (seen.has(obj)) return null;
        seen.add(obj);
        if (Array.isArray(obj)) return obj.map(clean);
        const res: any = {};
        for (const k in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, k)) {
                const v = obj[k];
                if (v !== undefined) res[k] = clean(v);
            }
        }
        return res;
    };
    return clean(data);
};

const generateWalletId = () => `NC-${Math.floor(1000 + Math.random() * 9000)}-${Math.floor(1000 + Math.random() * 9000)}`;
const generateHash = () => Array.from({ length: 64 }, () => Math.floor(Math.random() * 16).toString(16)).join('');
const generateSerialNumber = (standard: string, country: string, vintage: number, amount: number) => {
    const batch = Math.floor(Math.random() * 10000);
    const start = Math.floor(Math.random() * 1000000);
    const end = start + amount;
    const stdCode = standard.includes('ReplateIQ') ? 'RIQ' : standard.substring(0, 3).toUpperCase();
    return `${stdCode}-${country.substring(0, 2).toUpperCase()}-${vintage}-${batch}-${start}-${end}`;
};

// --- LOCAL DB ---
class LocalDB implements IDB {
    private usersKey = 'replateiq_db_users_v1';
    private listingsKey = 'replateiq_db_listings_v1';
    private chatsKey = 'replateiq_db_chats_v1';
    private b2bKey = 'replateiq_db_b2b_v1';
    private offersKey = 'replateiq_db_offers_v1';
    private sessionKey = 'replateiq_session_v1';

    private getUsers(): User[] { return JSON.parse(localStorage.getItem(this.usersKey) || '[]'); }
    private saveUsers(users: User[]) {
        localStorage.setItem(this.usersKey, JSON.stringify(users));
        window.dispatchEvent(new Event('local-db-users-change'));
    }
    private getOffers(): TradeOffer[] { return JSON.parse(localStorage.getItem(this.offersKey) || '[]'); }
    private saveOffers(offers: TradeOffer[]) {
        localStorage.setItem(this.offersKey, JSON.stringify(offers));
        window.dispatchEvent(new Event('local-db-offers-change'));
    }
    private getListings(): FoodListing[] { return JSON.parse(localStorage.getItem(this.listingsKey) || '[]'); }
    private saveListings(listings: FoodListing[]) { localStorage.setItem(this.listingsKey, JSON.stringify(listings)); window.dispatchEvent(new Event('local-db-listings-change')); }
    private getB2BListings(): B2BListing[] { return JSON.parse(localStorage.getItem(this.b2bKey) || '[]'); }
    private saveB2BListings(listings: B2BListing[]) { localStorage.setItem(this.b2bKey, JSON.stringify(listings)); window.dispatchEvent(new Event('local-db-b2b-change')); }
    private getChats(): ChatMessage[] { return JSON.parse(localStorage.getItem(this.chatsKey) || '[]'); }
    private saveChats(chats: ChatMessage[]) { localStorage.setItem(this.chatsKey, JSON.stringify(chats)); window.dispatchEvent(new Event('local-db-chats-change')); }

    onAuthStateChanged(callback: (user: User | null) => void): () => void {
        const current = this.getCurrentUser();
        callback(current);
        const handler = () => callback(this.getCurrentUser());
        window.addEventListener('local-session-change', handler);
        // Also listen for updates to the USER data itself (like balance changes)
        const userUpdateHandler = () => {
            const c = this.getCurrentUser();
            if (c) {
                const fresh = this.getUsers().find(u => u.id === c.id);
                if (fresh) {
                    localStorage.setItem(this.sessionKey, JSON.stringify(fresh));
                    callback(fresh);
                }
            }
        };
        window.addEventListener('local-db-users-change', userUpdateHandler);

        const storageHandler = (e: StorageEvent) => { if (e.key === this.sessionKey) handler(); };
        window.addEventListener('storage', storageHandler);
        return () => {
            window.removeEventListener('local-session-change', handler);
            window.removeEventListener('local-db-users-change', userUpdateHandler);
            window.removeEventListener('storage', storageHandler);
        };
    }
    async login(email: string, password?: string): Promise<void> {
        await new Promise(r => setTimeout(r, 800));
        const users = this.getUsers();
        const user = users.find(u => u.email.toLowerCase() === email.toLowerCase());
        if (!user) throw new Error("User not found.");
        if (password && user.password && user.password !== password) throw new Error("Incorrect password.");
        localStorage.setItem(this.sessionKey, JSON.stringify(user));
        window.dispatchEvent(new Event('local-session-change'));
    }
    async signup(user: User): Promise<void> {
        await new Promise(r => setTimeout(r, 800));
        const users = this.getUsers();
        if (users.some(u => u.email === user.email)) throw new Error("Email exists.");
        const newUser = { ...user, walletId: generateWalletId(), kycVerified: user.role === 'enterprise' };
        users.push(newUser);
        this.saveUsers(users);
        localStorage.setItem(this.sessionKey, JSON.stringify(newUser));
        window.dispatchEvent(new Event('local-session-change'));
    }
    async logout(): Promise<void> {
        localStorage.removeItem(this.sessionKey);
        window.dispatchEvent(new Event('local-session-change'));
    }
    getCurrentUser(): User | null {
        const session = localStorage.getItem(this.sessionKey);
        return session ? JSON.parse(session) : null;
    }
    async updateUser(id: string, data: Partial<User>) {
        const users = this.getUsers();
        const idx = users.findIndex(u => u.id === id);
        if (idx !== -1) {
            users[idx] = { ...users[idx], ...data };
            this.saveUsers(users);
            const current = this.getCurrentUser();
            if (current && current.id === id) {
                localStorage.setItem(this.sessionKey, JSON.stringify(users[idx]));
                window.dispatchEvent(new Event('local-session-change'));
            }
        }
    }
    async addPoints(userId: string, amount: number, description: string): Promise<void> {
        const users = this.getUsers();
        const idx = users.findIndex(u => u.id === userId);
        if (idx !== -1) {
            users[idx].walletBalance += amount;
            users[idx].pointsHistory.unshift({
                id: Date.now().toString(),
                date: new Date().toISOString(),
                amount,
                description,
                type: 'earned',
                standard: 'ReplateIQ Verified',
                verificationHash: generateHash()
            });
            this.saveUsers(users);
        }
    }

    async broadcastOffer(enterpriseId: string, enterpriseName: string, region: string, price: number): Promise<void> {
        const users = this.getUsers();
        const sellers = users.filter(u =>
            (u.role === 'user' || !u.role) && u.walletBalance > 0 &&
            (region === 'General Pool' || u.location.toLowerCase().includes(region.toLowerCase()))
        );
        const newOffers: TradeOffer[] = sellers.map(seller => ({
            id: 'offer-' + Date.now().toString() + '-' + Math.random().toString(36).substr(2, 9),
            enterpriseId,
            enterpriseName,
            targetUserId: seller.id,
            region,
            amount: seller.walletBalance,
            pricePerCredit: price,
            status: 'pending',
            createdAt: new Date().toISOString()
        }));
        const currentOffers = this.getOffers();
        this.saveOffers([...currentOffers, ...newOffers]);
    }

    async updateOfferPrice(offerId: string, newPrice: number): Promise<void> {
        const offers = this.getOffers();
        const idx = offers.findIndex(o => o.id === offerId);
        if (idx !== -1) {
            offers[idx].pricePerCredit = newPrice;
            this.saveOffers(offers);
        }
    }

    async acceptTradeOffer(offerId: string, userId: string): Promise<void> {
        const offers = this.getOffers();
        const offerIdx = offers.findIndex(o => o.id === offerId);
        if (offerIdx === -1) throw new Error("Offer not found");
        const offer = offers[offerIdx];
        if (offer.targetUserId !== userId) throw new Error("Unauthorized");
        if (offer.status !== 'pending') throw new Error("Offer processed");

        const users = this.getUsers();
        const userIdx = users.findIndex(u => u.id === userId);
        const entIdx = users.findIndex(u => u.id === offer.enterpriseId);

        if (userIdx === -1 || entIdx === -1) throw new Error("User error");
        if (users[userIdx].walletBalance < offer.amount) {
            offer.status = 'rejected'; this.saveOffers(offers); throw new Error("Insufficient balance");
        }

        const hash = generateHash();
        users[userIdx].walletBalance -= offer.amount;
        users[userIdx].pointsHistory.unshift({
            id: Date.now().toString(), date: new Date().toISOString(), amount: offer.amount,
            description: `Sold to ${offer.enterpriseName} @ $${offer.pricePerCredit}`, type: 'sold', verificationHash: hash
        });

        users[entIdx].walletBalance += offer.amount;
        users[entIdx].pointsHistory.unshift({
            id: Date.now().toString(), date: new Date().toISOString(), amount: offer.amount,
            description: `Acquired from User (${users[userIdx].name})`, type: 'bought', standard: 'ReplateIQ Verified', vintage: new Date().getFullYear(), verificationHash: hash
        });

        offer.status = 'accepted';
        this.saveUsers(users);
        this.saveOffers(offers);

        if (this.getCurrentUser()?.id === userId) {
            localStorage.setItem(this.sessionKey, JSON.stringify(users[userIdx]));
            window.dispatchEvent(new Event('local-session-change'));
        }
    }

    async rejectTradeOffer(offerId: string): Promise<void> {
        const offers = this.getOffers();
        const idx = offers.findIndex(o => o.id === offerId);
        if (idx !== -1) {
            offers[idx].status = 'rejected';
            this.saveOffers(offers);
        }
    }

    subscribeToUserOffers(userId: string, callback: (offers: TradeOffer[]) => void): () => void {
        const filter = () => this.getOffers().filter(o => o.targetUserId === userId && o.status === 'pending');
        callback(filter());
        const handler = () => callback(filter());
        window.addEventListener('local-db-offers-change', handler);
        const storageHandler = (e: StorageEvent) => { if (e.key === this.offersKey) handler(); };
        window.addEventListener('storage', storageHandler);
        return () => { window.removeEventListener('local-db-offers-change', handler); window.removeEventListener('storage', storageHandler); };
    }

    subscribeToEnterpriseBids(enterpriseId: string, callback: (offers: TradeOffer[]) => void): () => void {
        const filter = () => this.getOffers().filter(o => o.enterpriseId === enterpriseId && o.status === 'pending');
        callback(filter());
        const handler = () => callback(filter());
        window.addEventListener('local-db-offers-change', handler);
        const storageHandler = (e: StorageEvent) => { if (e.key === this.offersKey) handler(); };
        window.addEventListener('storage', storageHandler);
        return () => { window.removeEventListener('local-db-offers-change', handler); window.removeEventListener('storage', storageHandler); };
    }

    getCommunityProject(): CarbonProject { return COMMUNITY_PROJECT; }
    async createB2BListing(listing: B2BListing): Promise<void> {
        const users = this.getUsers();
        const seller = users.find(u => u.id === listing.sellerId);
        if (!seller || seller.walletBalance < listing.amount) throw new Error("Insufficient balance");
        listing.serialNumberRange = generateSerialNumber(listing.project.standard, listing.project.country, listing.vintage, listing.amount);
        seller.walletBalance -= listing.amount;
        seller.pointsHistory.unshift({
            id: Date.now().toString(), date: new Date().toISOString(), amount: listing.amount,
            description: `Listed: ${listing.project.name}`, type: 'listed', standard: listing.project.standard, verificationHash: generateHash(), serialNumber: listing.serialNumberRange
        });
        this.saveUsers(users);
        const currentListings = this.getB2BListings();
        this.saveB2BListings([...currentListings, listing]);
        if (this.getCurrentUser()?.id === seller.id) { localStorage.setItem(this.sessionKey, JSON.stringify(seller)); window.dispatchEvent(new Event('local-session-change')); }
    }
    async buyB2BListing(buyerId: string, listingId: string, amount: number, retire: boolean): Promise<void> {
        const listings = this.getB2BListings();
        const listingIdx = listings.findIndex(l => l.id === listingId);
        if (listingIdx === -1) throw new Error("Listing not found");
        const listing = listings[listingIdx];
        if (amount > listing.amount) throw new Error("Not enough credits");
        const users = this.getUsers();
        const buyerIdx = users.findIndex(u => u.id === buyerId);
        if (buyerIdx === -1) throw new Error("User error");

        const hash = generateHash();
        const subSerial = generateSerialNumber(listing.project.standard, listing.project.country, listing.vintage, amount);

        if (retire) {
            users[buyerIdx].retiredBalance = (users[buyerIdx].retiredBalance || 0) + amount;
            users[buyerIdx].pointsHistory.unshift({ id: Date.now().toString(), date: new Date().toISOString(), amount: amount, description: `OFFSET RETIRED: ${listing.project.name}`, type: 'retired', verificationHash: hash, standard: listing.project.standard, vintage: listing.vintage, serialNumber: subSerial });
        } else {
            users[buyerIdx].walletBalance += amount;
            users[buyerIdx].pointsHistory.unshift({ id: Date.now().toString(), date: new Date().toISOString(), amount: amount, description: `B2B Trade from ${listing.sellerName}`, type: 'bought', verificationHash: hash, standard: listing.project.standard, vintage: listing.vintage, serialNumber: subSerial });
        }
        listing.amount -= amount;
        if (listing.amount <= 0) { listing.status = 'sold'; listings.splice(listingIdx, 1); } else { listings[listingIdx] = listing; }
        this.saveUsers(users);
        this.saveB2BListings(listings);
        if (this.getCurrentUser()?.id === buyerId) { localStorage.setItem(this.sessionKey, JSON.stringify(users[buyerIdx])); window.dispatchEvent(new Event('local-session-change')); }
    }
    subscribeToB2BListings(cb: (l: B2BListing[]) => void) { cb(this.getB2BListings()); const handler = () => cb(this.getB2BListings()); window.addEventListener('local-db-b2b-change', handler); return () => window.removeEventListener('local-db-b2b-change', handler); }
    subscribeToListings(cb: (l: FoodListing[]) => void) { cb(this.getListings()); const handler = () => cb(this.getListings()); window.addEventListener('local-db-listings-change', handler); return () => window.removeEventListener('local-db-listings-change', handler); }
    subscribeToMessages(cb: (m: ChatMessage[]) => void) { cb(this.getChats()); const handler = () => cb(this.getChats()); window.addEventListener('local-db-chats-change', handler); return () => window.removeEventListener('local-db-chats-change', handler); }
    subscribeToUsers(cb: (users: User[]) => void) { cb(this.getUsers()); const handler = () => cb(this.getUsers()); window.addEventListener('local-db-users-change', handler); window.addEventListener('storage', (e) => { if (e.key === this.usersKey) handler(); }); return () => { window.removeEventListener('local-db-users-change', handler); }; }

    async addListing(l: FoodListing) { this.saveListings([l, ...this.getListings()]); }
    async updateListing(id: string, data: Partial<FoodListing>) { const l = this.getListings(); const idx = l.findIndex(x => x.id === id); if (idx !== -1) { l[idx] = { ...l[idx], ...data }; this.saveListings(l); } }
    async deleteListing(id: string) { const l = this.getListings(); const idx = l.findIndex(x => x.id === id); if (idx !== -1) { l[idx].status = 'deleted'; this.saveListings(l); } }
    async sendMessage(m: ChatMessage) { this.saveChats([...this.getChats(), m]); }
    async getAllUsers() { return this.getUsers(); }
    async transferCredits(userId: string, region: string, amount: number) { }
    async unclaimListing(id: string) {
        const l = this.getListings();
        const idx = l.findIndex(x => x.id === id);
        if (idx !== -1) {
            l[idx] = { ...l[idx], status: 'available', claimedBy: undefined, claimedByName: undefined, claimCode: undefined, pickupMethod: undefined };
            this.saveListings(l);
        }
    }
    async verifyTransaction(listingId: string, code: string): Promise<boolean> {
        const l = this.getListings();
        const idx = l.findIndex(x => x.id === listingId);
        if (idx === -1) throw new Error("Listing not found");
        const listing = l[idx];

        if (listing.claimCode !== code) throw new Error("Invalid Code");
        if (listing.status !== 'claimed') throw new Error("Not claimed");

        // Mock Server Logic in Local Mode
        const points = Math.round((listing.carbonSaved || 0) * 10) + 5;
        const splitPoints = Math.floor(points / 2);

        const users = this.getUsers();
        const giverIdx = users.findIndex(u => u.id === listing.giverId);
        const receiverIdx = users.findIndex(u => u.id === listing.claimedBy);

        const hash = generateHash();
        const pd = new Date().toISOString();

        if (giverIdx !== -1) {
            users[giverIdx].walletBalance += splitPoints;
            users[giverIdx].pointsHistory.unshift({ id: Date.now().toString(), date: pd, amount: splitPoints, description: `Food Rescued (Local)`, type: 'earned', verificationHash: hash });
        }
        if (receiverIdx !== -1) {
            users[receiverIdx].walletBalance += splitPoints;
            users[receiverIdx].pointsHistory.unshift({ id: (Date.now() + 1).toString(), date: pd, amount: splitPoints, description: `Verified Pickup (Local)`, type: 'earned', verificationHash: hash });
        }

        l[idx].status = 'completed';
        this.saveListings(l);
        this.saveUsers(users);
        return true;
    }
}

// --- FIREBASE DB ---
class FirebaseDB implements IDB {
    onAuthStateChanged(callback: (user: User | null) => void): () => void {
        if (!firebaseAuth) return () => { };

        let unsubscribeSnapshot: (() => void) | null = null;

        const unsubscribeAuth = onAuthStateChanged(firebaseAuth, async (fbUser) => {
            // 1. Unsubscribe from previous listener FIRST
            if (unsubscribeSnapshot) {
                unsubscribeSnapshot();
                unsubscribeSnapshot = null;
            }

            if (fbUser) {
                const docRef = doc(firebaseFirestore, "users", fbUser.uid);
                // 2. Set up new listener
                unsubscribeSnapshot = onSnapshot(docRef,
                    (s) => {
                        if (s.exists()) {
                            callback({ id: fbUser.uid, ...s.data() } as User);
                        }
                    },
                    (error) => {
                        // 3. Robust Error Handling for Logout Race Conditions
                        if (error.code !== 'permission-denied') {
                            console.error("Auth profile sync error:", error);
                        } else {
                            // If permission denied (likely logout happened), trigger null callback safely
                            callback(null);
                        }
                    }
                );
            } else {
                callback(null);
            }
        });

        // Cleanup: Unsubscribe both Auth and Snapshot
        return () => {
            unsubscribeAuth();
            if (unsubscribeSnapshot) unsubscribeSnapshot();
        };
    }

    async login(email: string, password?: string) { if (firebaseAuth) await signInWithEmailAndPassword(firebaseAuth, email, password || "123456"); }
    async signup(user: User) {
        if (!firebaseAuth) return;
        const cred = await createUserWithEmailAndPassword(firebaseAuth, user.email, user.password || "123456");
        await updateProfile(cred.user, { displayName: user.name });
        const { password, ...safe } = user;
        await setDoc(doc(firebaseFirestore, "users", cred.user.uid), { ...safe, walletId: generateWalletId(), id: cred.user.uid });
    }
    async logout() { if (firebaseAuth) await signOut(firebaseAuth); }
    getCurrentUser() { return null; }
    async updateUser(id: string, data: Partial<User>) { if (firebaseFirestore) await updateDoc(doc(firebaseFirestore, "users", id), sanitizeData(data)); }
    async addPoints(userId: string, amount: number, description: string) {
        if (!firebaseFirestore) return;
        const userRef = doc(firebaseFirestore, "users", userId);
        const transaction: PointTransaction = { id: Date.now().toString(), date: new Date().toISOString(), amount, description, type: 'earned', standard: 'ReplateIQ Verified', verificationHash: generateHash() };
        await runTransaction(firebaseFirestore, async (t) => {
            const uDoc = await t.get(userRef);
            if (!uDoc.exists()) throw "User not found";
            t.update(userRef, { walletBalance: (uDoc.data().walletBalance || 0) + amount, pointsHistory: [transaction, ...(uDoc.data().pointsHistory || [])] });
        });
    }
    async broadcastOffer(enterpriseId: string, enterpriseName: string, region: string, price: number) {
        if (!firebaseFirestore) return;

        // 1. Get Existing Offers for this Enterpise to prevent duplicates (Idempotency)
        const existingOffersSnapshot = await getDocs(query(
            collection(firebaseFirestore, "trade_offers"),
            where("enterpriseId", "==", enterpriseId),
            where("status", "==", "pending")
        ));
        const existingOffersMap = new Map(); // userId -> offerId
        existingOffersSnapshot.forEach(doc => {
            const data = doc.data() as TradeOffer;
            existingOffersMap.set(data.targetUserId, doc.id);
        });

        const batch = writeBatch(firebaseFirestore);
        const usersSnap = await getDocs(collection(firebaseFirestore, "users"));
        let count = 0;

        usersSnap.forEach(u => {
            const userData = u.data() as User;
            const isUser = userData.role === 'user' || !userData.role;
            const matchesRegion = region === 'General Pool' || (userData.location && userData.location.toLowerCase().includes(region.toLowerCase()));

            if (isUser && (userData.walletBalance || 0) > 0 && matchesRegion && count < 490) {
                // Check if we already have an offer for this user
                if (existingOffersMap.has(u.id)) {
                    // UPDATE existing offer
                    const offerId = existingOffersMap.get(u.id);
                    const ref = doc(firebaseFirestore, "trade_offers", offerId);
                    batch.update(ref, {
                        pricePerCredit: price,
                        amount: userData.walletBalance, // Update amount in case user balance changed
                        region: region // Update region label if changed
                    });
                } else {
                    // CREATE new offer
                    const ref = doc(collection(firebaseFirestore, "trade_offers"));
                    batch.set(ref, {
                        id: ref.id,
                        enterpriseId,
                        enterpriseName,
                        targetUserId: u.id,
                        targetUserName: userData.name, // [NEW] Store name
                        region,
                        amount: userData.walletBalance,
                        pricePerCredit: price,
                        status: 'pending',
                        createdAt: new Date().toISOString()
                    });
                }
                count++;
            }
        });
        if (count > 0) await batch.commit();
    }
    async updateOfferPrice(offerId: string, newPrice: number) {
        if (firebaseFirestore) await updateDoc(doc(firebaseFirestore, "trade_offers", offerId), { pricePerCredit: newPrice });
    }
    async acceptTradeOffer(offerId: string, userId: string) {
        if (!firebaseFirestore) return;
        await runTransaction(firebaseFirestore, async (t) => {
            const offerRef = doc(firebaseFirestore, "trade_offers", offerId);
            const offerSnap = await t.get(offerRef);
            if (!offerSnap.exists()) throw "Offer not found";
            const offer = offerSnap.data() as TradeOffer;
            if (offer.status !== 'pending') throw "Offer processed";

            const userRef = doc(firebaseFirestore, "users", userId);
            const entRef = doc(firebaseFirestore, "users", offer.enterpriseId);
            const userSnap = await t.get(userRef);
            const entSnap = await t.get(entRef);

            const userData = userSnap.data() as User;
            if (userData.walletBalance < offer.amount) { t.update(offerRef, { status: 'rejected' }); throw "Insufficient balance"; }
            const hash = generateHash();
            t.update(userRef, { walletBalance: userData.walletBalance - offer.amount, pointsHistory: [{ id: Date.now().toString(), date: new Date().toISOString(), amount: offer.amount, description: `Sold to ${offer.enterpriseName}`, type: 'sold', verificationHash: hash }, ...(userData.pointsHistory || [])] });
            t.update(entRef, { walletBalance: (entSnap.data().walletBalance || 0) + offer.amount, pointsHistory: [{ id: Date.now().toString(), date: new Date().toISOString(), amount: offer.amount, description: `Acquired from User`, type: 'bought', standard: 'ReplateIQ Verified', vintage: new Date().getFullYear(), verificationHash: hash }, ...(entSnap.data().pointsHistory || [])] });
            t.update(offerRef, { status: 'accepted' });
        });
    }
    async rejectTradeOffer(offerId: string) {
        if (firebaseFirestore) await updateDoc(doc(firebaseFirestore, "trade_offers", offerId), { status: 'rejected' });
    }
    subscribeToUserOffers(userId: string, cb: (offers: TradeOffer[]) => void) {
        if (!firebaseFirestore) return () => { };
        return onSnapshot(
            query(collection(firebaseFirestore, "trade_offers"), where("targetUserId", "==", userId)),
            (s) => {
                const offers = s.docs.map(d => d.data() as TradeOffer).filter(o => o.status === 'pending');
                cb(offers);
            },
            (error) => console.warn("Error subscribing to user offers", error.code)
        );
    }
    subscribeToEnterpriseBids(enterpriseId: string, cb: (offers: TradeOffer[]) => void) {
        if (!firebaseFirestore) return () => { };
        return onSnapshot(
            query(collection(firebaseFirestore, "trade_offers"), where("enterpriseId", "==", enterpriseId)),
            (s) => {
                const offers = s.docs.map(d => d.data() as TradeOffer).filter(o => o.status === 'pending');
                cb(offers);
            },
            (error) => console.warn("Error subscribing to enterprise bids", error.code)
        );
    }
    getCommunityProject() { return COMMUNITY_PROJECT; }
    async createB2BListing(listing: B2BListing) {
        if (!firebaseFirestore) return;
        const sellerRef = doc(firebaseFirestore, "users", listing.sellerId);
        await runTransaction(firebaseFirestore, async (t) => {
            const sellerSnap = await t.get(sellerRef);
            if (!sellerSnap.exists()) throw "Seller not found";
            if (sellerSnap.data().walletBalance < listing.amount) throw "Insufficient balance";
            t.update(sellerRef, { walletBalance: sellerSnap.data().walletBalance - listing.amount, pointsHistory: [{ id: Date.now().toString(), date: new Date().toISOString(), amount: listing.amount, description: `Listed: ${listing.project.name}`, type: 'listed', standard: listing.project.standard, verificationHash: generateHash(), serialNumber: listing.serialNumberRange }, ...(sellerSnap.data().pointsHistory || [])] });
            const ref = doc(collection(firebaseFirestore, "b2b_listings"));
            t.set(ref, sanitizeData({ ...listing, id: ref.id }));
        });
    }
    async buyB2BListing(buyerId: string, listingId: string, amount: number, retire: boolean) {
        if (!firebaseFirestore) return;
        await runTransaction(firebaseFirestore, async (t) => {
            const listingRef = doc(firebaseFirestore, "b2b_listings", listingId);
            const buyerRef = doc(firebaseFirestore, "users", buyerId);
            const lSnap = await t.get(listingRef);
            const bSnap = await t.get(buyerRef);
            const list = lSnap.data() as B2BListing;
            if (list.amount < amount) throw "Not enough credits";
            const hash = generateHash();
            if (retire) {
                t.update(buyerRef, { retiredBalance: (bSnap.data().retiredBalance || 0) + amount, pointsHistory: [{ id: Date.now().toString(), date: new Date().toISOString(), amount, description: `OFFSET RETIRED`, type: 'retired', verificationHash: hash, standard: list.project.standard, vintage: list.vintage }, ...(bSnap.data().pointsHistory || [])] });
            } else {
                t.update(buyerRef, { walletBalance: (bSnap.data().walletBalance || 0) + amount, pointsHistory: [{ id: Date.now().toString(), date: new Date().toISOString(), amount, description: `B2B Trade`, type: 'bought', verificationHash: hash, standard: list.project.standard, vintage: list.vintage }, ...(bSnap.data().pointsHistory || [])] });
            }
            if (list.amount - amount <= 0) t.update(listingRef, { amount: 0, status: 'sold' }); else t.update(listingRef, { amount: list.amount - amount });
        });
    }
    subscribeToB2BListings(cb: (l: B2BListing[]) => void) { if (!firebaseFirestore) return () => { }; return onSnapshot(query(collection(firebaseFirestore, "b2b_listings"), limit(50)), (s) => cb(s.docs.map(d => ({ id: d.id, ...d.data() } as B2BListing))), (error) => console.warn("B2B listings subscribe error", error.code)); }
    subscribeToListings(cb: (l: FoodListing[]) => void) { if (!firebaseFirestore) return () => { }; return onSnapshot(query(collection(firebaseFirestore, "listings"), orderBy("createdAt", "desc"), limit(100)), (s) => cb(s.docs.map(d => ({ id: d.id, ...d.data() } as FoodListing))), (error) => console.warn("Listings subscribe error", error.code)); }
    subscribeToMessages(cb: (m: ChatMessage[]) => void) { if (!firebaseFirestore) return () => { }; return onSnapshot(query(collection(firebaseFirestore, "messages"), orderBy("timestamp", "desc"), limit(200)), (s) => cb(s.docs.map(d => ({ id: d.id, ...d.data() } as ChatMessage)).reverse()), (error) => console.warn("Messages subscribe error", error.code)); }
    subscribeToUsers(cb: (users: User[]) => void) { if (!firebaseFirestore) return () => { }; return onSnapshot(query(collection(firebaseFirestore, "users"), limit(100)), (s) => cb(s.docs.map(d => ({ id: d.id, ...d.data() } as User))), (error) => console.warn("Users subscribe error", error.code)); }
    async addListing(l: FoodListing) { if (firebaseFirestore) { const { id, ...d } = l; await addDoc(collection(firebaseFirestore, "listings"), sanitizeData(d)); } }
    async updateListing(id: string, d: Partial<FoodListing>) { if (firebaseFirestore) await updateDoc(doc(firebaseFirestore, "listings", id), sanitizeData(d)); }
    async deleteListing(id: string) { if (firebaseFirestore) await updateDoc(doc(firebaseFirestore, "listings", id), { status: 'deleted' }); }
    async sendMessage(m: ChatMessage) { if (firebaseFirestore) { const { id, ...d } = m; await addDoc(collection(firebaseFirestore, "messages"), sanitizeData(d)); } }
    async getAllUsers() { if (!firebaseFirestore) return []; const s = await getDocs(query(collection(firebaseFirestore, "users"), limit(100))); return s.docs.map(d => ({ id: d.id, ...d.data() } as User)); }
    async transferCredits(userId: string, region: string, amount: number) { }
    async unclaimListing(id: string) {
        if (firebaseFirestore) await updateDoc(doc(firebaseFirestore, "listings", id), { status: 'available', claimedBy: null, claimedByName: null, claimCode: null, pickupMethod: null });
    }
    async verifyTransaction(listingId: string, code: string): Promise<boolean> {
        if (!process.env.VITE_FIREBASE_API_KEY && !USE_FIREBASE) return false; // Safety
        try {
            const functions = getFunctions(firebaseApp);
            const verifyFn = httpsCallable(functions, 'verifyTransaction');
            await verifyFn({ listingId, code });
            return true;
        } catch (e) {
            console.error("Secure Verification Failed", e);
            throw e;
        }
    }
}

export const db = USE_FIREBASE ? new FirebaseDB() : new LocalDB();
